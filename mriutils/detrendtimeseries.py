def detrendtimeseries(arr, polydeg=1, mode='subtract'):
    '''
    detrendtimeseries(arr, polydeg=1, mode='subtract'):

    Regress out low frequency component in time series using polynomial fit.
    Note that another useful function is scipy.

    Input:
        <arr>: 1d or 2d array. 2d is T time points x M voxels.
        <polydeg>: int, the polynomial order to capture the low frequency
            drift. Default:1
        <mode>: a string, specify how to remove low frequency stuff, can be
            'subtract': default, meaning subtract the low frequency stuff
            'divide': divide original time series by
    Output:
        <detrendArray>: T x M array, the array after detrend
        <polycoefficients>: array with shape (polydeg + 1, M), get from polyfit function
        <array_polyfit>: T x M array, fitted array generated by polyval

    Note that output of numpy.polyfit and numpy.polynomial.polynomial are different
    numpy.polyfit output coefficients corresponding to the polydeg from high to low.
    numpy.polynomial.polynomial is vice versa. This will cause problem when using polyval

    if you use np.polyfit, use np.polyval
    if you use numpy.polynomial.polynomial.polyfit, use numpy.polynomial.polynomial.polyval
    Here we all use later case.

    Examples:

    To do:
        1. replace the fitting procedure using the rz.stats.polyfit1d
        2. deal with nan

    '''

    from numpy import ndarray, linspace
    from numpy.polynomial.polynomial import polyval,polyfit

    assert isinstance(arr, ndarray), 'Input is not an array!'
    assert arr.ndim <= 2, 'Input should be 1d or 2d'

    # do 1d polyfit
    nTimePts = arr.shape[0]

    time = linspace(1, nTimePts, nTimePts)
    p = polyfit(time, arr, polydeg)  # p is a (polydeg + 1, M)

    # evaluate fitted poly model
    arr_polyfit = polyval(time, p, tensor=True).T
    # note here we take the transpose, the original polyval flip the dimension, weird..
    # array_polyfit is a T x M array

    if mode == 'subtract':
        return arr - arr_polyfit, p, arr_polyfit
    elif mode == 'divide':
        return arr / arr_polyfit, p, arr_polyfit





